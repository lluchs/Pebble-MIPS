
#define INSTR_NUM (sizeof(instructions) / sizeof(instructions[0]))

char *instructions[][2] = {
{"abs Rdest, Rsrc",
 "Absolute Value †"},
{"add Rdest, Rsrc1, Src2",
 "Addition (with overflow)"},
{"addi Rdest, Rsrc1, Imm",
 "Addition Immediate (with overflow)"},
{"addu Rdest, Rsrc1, Src2",
 "Addition (without overflow)"},
{"addiu Rdest, Rsrc1, Imm",
 "Addition Immediate (without overflow)"},
{"and Rdest, Rsrc1, Src2",
 "AND"},
{"andi Rdest, Rsrc1, Imm",
 "AND Immediate"},
{"div Rsrc1, Rsrc2",
 "Divide (with overflow)"},
{"divu Rsrc1, Rsrc2",
 "Divide (without overflow)"},
{"div Rdest, Rsrc1, Src2",
 "Divide (with overflow) †"},
{"divu Rdest, Rsrc1, Src2",
 "Divide (without overflow) †"},
{"mul Rdest, Rsrc1, Src2",
 "Multiply (without overflow) †"},
{"mulo Rdest, Rsrc1, Src2",
 "Multiply (with overflow) †"},
{"mulou Rdest, Rsrc1, Src2",
 "Unsigned Multiply (with overflow) †"},
{"mult Rsrc1, Rsrc2",
 "Multiply"},
{"multu Rsrc1, Rsrc2",
 "Unsigned Multiply"},
{"neg Rdest, Rsrc",
 "Negate Value (with overflow) †"},
{"negu Rdest, Rsrc",
 "Negate Value (without overflow) †"},
{"nor Rdest, Rsrc1, Src2",
 "NOR"},
{"not Rdest, Rsrc",
 "NOT †"},
{"or Rdest, Rsrc1, Src2",
 "OR"},
{"ori Rdest, Rsrc1, Imm",
 "OR Immediate"},
{"rem Rdest, Rsrc1, Src2",
 "Remainder †"},
{"remu Rdest, Rsrc1, Src2",
 "Unsigned Remainder †"},
{"rol Rdest, Rsrc1, Src2",
 "Rotate Left †"},
{"ror Rdest, Rsrc1, Src2",
 "Rotate Right †"},
{"sll Rdest, Rsrc1, Src2",
 "Shift Left Logical"},
{"sllv Rdest, Rsrc1, Rsrc2",
 "Shift Left Logical Variable"},
{"sra Rdest, Rsrc1, Src2",
 "Shift Right Arithmetic"},
{"srav Rdest, Rsrc1, Rsrc2",
 "Shift Right Arithmetic Variable"},
{"srl Rdest, Rsrc1, Src2",
 "Shift Right Logical"},
{"srlv Rdest, Rsrc1, Rsrc2",
 "Shift Right Logical Variable"},
{"sub Rdest, Rsrc1, Src2",
 "Subtract (with overflow)"},
{"subu Rdest, Rsrc1, Src2",
 "Subtract (without overflow)"},
{"xor Rdest, Rsrc1, Src2",
 "XOR"},
{"xori Rdest, Rsrc1, Imm",
 "XOR Immediate"},
{"li Rdest, Imm",
 "Load Immediate †"},
{"lui Rdest, Imm",
 "Load Upper Immediate"},
{"seq Rdest, Rsrc1, Src2",
 "Set Equal †"},
{"sge Rdest, Rsrc1, Src2",
 "Set Greater Than Equal †"},
{"sgeu Rdest, Rsrc1, Src2",
 "Set Greater Than Equal Unsigned †"},
{"sgt Rdest, Rsrc1, Src2",
 "Set Greater Than †"},
{"sgtu Rdest, Rsrc1, Src2",
 "Set Greater Than Unsigned †"},
{"sle Rdest, Rsrc1, Src2",
 "Set Less Than Equal †"},
{"sleu Rdest, Rsrc1, Src2",
 "Set Less Than Equal Unsigned †"},
{"slt Rdest, Rsrc1, Src2",
 "Set Less Than"},
{"slti Rdest, Rsrc1, Imm",
 "Set Less Than Immediate"},
{"sltu Rdest, Rsrc1, Src2",
 "Set Less Than Unsigned"},
{"sltiu Rdest, Rsrc1, Imm",
 "Set Less Than Unsigned Immediate"},
{"sne Rdest, Rsrc1, Src2",
 "Set Not Equal †"},
{"b label",
 "Branch instruction †"},
{"bal label",
 "Branch And Link †"},
{"bczt label",
 "Branch Coprocessor z True"},
{"bczf label",
 "Branch Coprocessor z False"},
{"beq Rsrc1, Src2, label",
 "Branch on Equal"},
{"beqz Rsrc, label",
 "Branch on Equal Zero †"},
{"bge Rsrc1, Src2, label",
 "Branch on Greater Than Equal †"},
{"bgeu Rsrc1, Src2, label",
 "Branch on GTE Unsigned †"},
{"bgez Rsrc, label",
 "Branch on Greater Than Equal Zero"},
{"bgezal Rsrc, label",
 "Branch on Greater Than Equal Zero And Link"},
{"bgt Rsrc1, Src2, label",
 "Branch on Greater Than †"},
{"bgtu Rsrc1, Src2, label",
 "Branch on Greater Than Unsigned †"},
{"bgtz Rsrc, label",
 "Branch on Greater Than Zero"},
{"ble Rsrc1, Src2, label",
 "Branch on Less Than Equal †"},
{"bleu Rsrc1, Src2, label",
 "Branch on LTE Unsigned †"},
{"blez Rsrc, label",
 "Branch on Less Than Equal Zero"},
{"bgezal Rsrc, label",
 "Branch on Greater Than Equal Zero And Link"},
{"bltzal Rsrc, label",
 "Branch on Less Than And Link"},
{"blt Rsrc1, Src2, label",
 "Branch on Less Than †"},
{"bltu Rsrc1, Src2, label",
 "Branch on Less Than Unsigned †"},
{"bltz Rsrc, label",
 "Branch on Less Than Zero"},
{"bne Rsrc1, Src2, label",
 "Branch on Not Equal"},
{"bnez Rsrc, label",
 "Branch on Not Equal Zero †"},
{"j label",
 "Jump"},
{"jal label",
 "Jump and Link"},
{"jalr Rsrc",
 "Jump and Link Register"},
{"jr Rsrc",
 "Jump Register"},
{"la Rdest, address",
 "Load Address †"},
{"lb Rdest, address",
 "Load Byte"},
{"lbu Rdest, address",
 "Load Unsigned Byte"},
{"ld Rdest, address",
 "Load Double-Word †"},
{"lh Rdest, address",
 "Load Halfword"},
{"lhu Rdest, address",
 "Load Unsigned Halfword"},
{"lw Rdest, address",
 "Load Word †"},
{"lwcz Rdest, address",
 "Load Word Coprocessor"},
{"lwl Rdest, address",
 "Load Word Left"},
{"lwr Rdest, address",
 "Load Word Right"},
{"ulh Rdest, address",
 "Unaligned Load Halfword †"},
{"ulhu Rdest, address",
 "Unaligned Load Halfword Unsigned †"},
{"ulw Rdest, address",
 "Unaligned Load Word †"},
{"sb Rsrc, address",
 "Store Byte"},
{"sd Rsrc, address",
 "Store Double-Word †"},
{"sh Rsrc, address",
 "Store Halfword"},
{"sw Rsrc, address",
 "Store Word"},
{"swcz Rsrc, address",
 "Store Word Coprocessor"},
{"swl Rsrc, address",
 "Store Word Left"},
{"swr Rsrc, address",
 "Store Word Right"},
{"ush Rsrc, address",
 "Unaligned Store Halfword †"},
{"usw Rsrc, address",
 "Unaligned Store Word †"},
{"move Rdest, Rsrc",
 "Move †"},
{"mfhi Rdest",
 "Move From hi"},
{"mflo Rdest",
 "Move From lo"},
{"mthi Rsrc",
 "Move To hi"},
{"mtlo Rsrc",
 "Move To lo"},
{"mfcz Rdest, CPsrc",
 "Move From Coprocessor z"},
{"mfc1.d Rdest, FRsrc1",
 "Move Double From Coprocessor 1 †"},
{"mtc1.d Rsrc, FRdest1",
 "Move Double To Coprocessor 1 †"},
{"mtcz Rsrc, CPdest",
 "Move To Coprocessor z"},
{"rfe",
 "Return From Exception"},
{"syscall",
 "System Call"},
{"break n",
 "Break"},
{"nop",
 "No operation †"},
};
